<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BeatSmith - DAW</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a1a;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            padding: 20px;
            min-width: 1200px;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            gap: 30px;
            padding: 15px 20px;
            background: #252525;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .logo span {
            color: #ff6600;
        }

        .transport-controls {
            display: flex;
            gap: 10px;
        }

        .transport-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #333;
            color: #fff;
            font-size: 16px;
            transition: all 0.2s;
        }

        .transport-btn:hover {
            background: #444;
        }

        .transport-btn.play-btn {
            color: #ff6600;
        }

        .transport-btn.active {
            background: #ff6600;
            color: #fff;
        }

        .param-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .param-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
        }

        .param-input {
            width: 60px;
            height: 32px;
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
            color: #ff6600;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
        }

        .param-input:focus {
            outline: none;
            border-color: #ff6600;
        }

        .play-mode-btn {
            padding: 8px 20px;
            background: #ff6600;
            border: none;
            border-radius: 4px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 12px;
        }

        .play-mode-btn.song-mode {
            background: #00aa66;
        }

        .export-btn {
            padding: 10px 20px;
            background: transparent;
            border: 2px solid #ff6600;
            border-radius: 4px;
            color: #ff6600;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: auto;
        }

        .export-btn:hover {
            background: #ff6600;
            color: #fff;
        }

        .export-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Main Content */
        .main-content {
            display: flex;
            gap: 20px;
        }

        /* Sound Source Panel */
        .sound-panel {
            width: 280px;
            flex-shrink: 0;
        }

        .panel-header {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }

        .sound-row {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #2a2a2a;
        }

        .sound-controls {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-right: 10px;
        }

        .mini-btn {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            background: #333;
            color: #666;
        }

        .mini-btn.active {
            background: #ff6600;
            color: #fff;
        }

        .mini-btn.solo.active {
            background: #00aa66;
        }

        .sound-name {
            width: 90px;
            font-size: 13px;
            font-weight: 500;
        }

        .knob-group {
            display: flex;
            gap: 10px;
        }

        .knob-container {
            text-align: center;
        }

        .knob-label {
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .knob-input {
            width: 45px;
            height: 24px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 3px;
            color: #ff6600;
            text-align: center;
            font-size: 11px;
        }

        .knob-input:focus {
            outline: none;
            border-color: #ff6600;
        }

        /* Step Sequencer */
        .sequencer-panel {
            flex: 1;
        }

        .beat-markers {
            display: flex;
            margin-left: 0;
            margin-bottom: 5px;
        }

        .beat-marker {
            width: 200px;
            text-align: center;
            font-size: 14px;
            color: #666;
            font-weight: bold;
        }

        .step-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .step-row {
            display: flex;
            gap: 4px;
        }

        .step {
            width: 45px;
            height: 40px;
            background: #2a2a2a;
            border: 1px solid #333;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.1s;
        }

        .step:hover {
            background: #3a3a3a;
            border-color: #555;
        }

        .step.active {
            background: #ff6600;
            border-color: #ff8833;
        }

        .step.playing {
            box-shadow: 0 0 10px #ff6600, inset 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .step.beat-start {
            margin-left: 8px;
        }

        .step:first-child {
            margin-left: 0;
        }

        /* Bottom Section */
        .bottom-section {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        /* Pattern Bank */
        .pattern-bank {
            width: 280px;
            flex-shrink: 0;
        }

        .pattern-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .pattern-btn {
            padding: 15px;
            background: #2a2a2a;
            border: 2px solid #333;
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pattern-btn:hover {
            border-color: #555;
        }

        .pattern-btn.selected {
            background: #ff6600;
            border-color: #ff6600;
        }

        .pattern-btn.playing {
            box-shadow: 0 0 15px rgba(255, 102, 0, 0.5);
        }

        /* Song Arrangement */
        .arrangement-panel {
            flex: 1;
        }

        .arrangement-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .clear-btn {
            padding: 5px 15px;
            background: transparent;
            border: 1px solid #ff4444;
            border-radius: 4px;
            color: #ff4444;
            font-size: 11px;
            cursor: pointer;
            text-transform: uppercase;
        }

        .clear-btn:hover {
            background: #ff4444;
            color: #fff;
        }

        .timeline {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 20px;
            background: #252525;
            border-radius: 8px;
            min-height: 80px;
            overflow-x: auto;
        }

        .timeline-slot {
            position: relative;
            min-width: 120px;
            padding: 15px 20px;
            background: #333;
            border: 2px solid #444;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timeline-slot:hover {
            border-color: #666;
        }

        .timeline-slot.playing {
            border-color: #ff6600;
            box-shadow: 0 0 15px rgba(255, 102, 0, 0.3);
        }

        .timeline-slot .slot-number {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a1a;
            padding: 2px 8px;
            font-size: 10px;
            color: #666;
            border-radius: 10px;
        }

        .timeline-slot .remove-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #ff4444;
            border: none;
            border-radius: 50%;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            display: none;
        }

        .timeline-slot:hover .remove-btn {
            display: block;
        }

        .timeline-connector {
            width: 20px;
            height: 2px;
            background: #444;
        }

        .add-slot {
            min-width: 60px;
            height: 50px;
            background: transparent;
            border: 2px dashed #444;
            border-radius: 6px;
            color: #666;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .add-slot:hover {
            border-color: #ff6600;
            color: #ff6600;
        }

        /* Pattern Selector Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #252525;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
        }

        .modal-title {
            margin-bottom: 20px;
            font-size: 18px;
        }

        .modal-patterns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .modal-pattern-btn {
            padding: 15px 30px;
            background: #333;
            border: 2px solid #444;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-pattern-btn:hover {
            border-color: #ff6600;
            background: #ff6600;
        }

        /* Playhead indicator */
        .playhead-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #ff6600;
            border-radius: 20px;
            font-size: 12px;
            display: none;
        }

        .playhead-indicator.show {
            display: block;
        }

        /* Responsive adjustments */
        @media (max-width: 1400px) {
            .step {
                width: 40px;
                height: 35px;
            }
            .beat-marker {
                width: 176px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="logo">BEAT<span>SMITH</span></div>
            
            <div class="transport-controls">
                <button class="transport-btn stop-btn" onclick="stopPlayback()" title="Stop">■</button>
                <button class="transport-btn play-btn" onclick="togglePlayback()" title="Play">▶</button>
            </div>

            <div class="param-group">
                <span class="param-label">BPM</span>
                <input type="number" class="param-input" id="bpm" value="128" min="60" max="200" onchange="updateBPM()">
            </div>

            <div class="param-group">
                <span class="param-label">SWING %</span>
                <input type="number" class="param-input" id="swing" value="20" min="0" max="100">
            </div>

            <div class="param-group">
                <span class="param-label">PLAY MODE</span>
                <button class="play-mode-btn" id="playModeBtn" onclick="togglePlayMode()">PATTERN</button>
            </div>

            <div class="param-group">
                <span class="param-label">LENGTH(S)</span>
                <input type="number" class="param-input" id="length" value="30" min="1" max="300">
            </div>

            <button class="export-btn" onclick="exportWAV()" id="exportBtn">EXPORT .WAV</button>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Sound Source Panel -->
            <div class="sound-panel">
                <div class="panel-header">SOUND SOURCE / MIX</div>
                <div id="soundRows"></div>
            </div>

            <!-- Step Sequencer -->
            <div class="sequencer-panel">
                <div class="beat-markers">
                    <div class="beat-marker">1</div>
                    <div class="beat-marker">2</div>
                    <div class="beat-marker">3</div>
                    <div class="beat-marker">4</div>
                </div>
                <div class="step-grid" id="stepGrid"></div>
            </div>
        </div>

        <!-- Bottom Section -->
        <div class="bottom-section">
            <!-- Pattern Bank -->
            <div class="pattern-bank">
                <div class="panel-header">PATTERN BANK</div>
                <div class="pattern-grid" id="patternGrid"></div>
            </div>

            <!-- Song Arrangement -->
            <div class="arrangement-panel">
                <div class="arrangement-header">
                    <div class="panel-header" style="border: none; margin: 0;">SONG ARRANGEMENT (TIMELINE)</div>
                    <button class="clear-btn" onclick="clearSong()">CLEAR SONG</button>
                </div>
                <div class="timeline" id="timeline"></div>
            </div>
        </div>
    </div>

    <!-- Pattern Selector Modal -->
    <div class="modal" id="patternModal">
        <div class="modal-content">
            <div class="modal-title">Select Pattern</div>
            <div class="modal-patterns" id="modalPatterns"></div>
        </div>
    </div>

    <div class="playhead-indicator" id="playheadIndicator"></div>

    <script>
        // Audio Context
        let audioContext = null;
        let isPlaying = false;
        let currentStep = 0;
        let intervalId = null;
        let playMode = 'pattern'; // 'pattern' or 'song'
        let currentSongIndex = 0;

        // Sound definitions
        const sounds = [
            { name: 'Kick 808', db: 0, pan: 0, mute: false, solo: false, type: 'kick' },
            { name: 'Snare Hard', db: -2, pan: 0, mute: false, solo: false, type: 'snare' },
            { name: 'Hat Closed', db: -4, pan: -0.2, mute: false, solo: false, type: 'hihat' },
            { name: 'Hat Open', db: -4, pan: 0.2, mute: false, solo: false, type: 'openhat' },
            { name: 'Clap', db: -3, pan: 0, mute: false, solo: false, type: 'clap' },
            { name: 'Perc Click', db: -6, pan: 0.3, mute: false, solo: false, type: 'perc' },
            { name: 'Bass 808', db: -2, pan: 0, mute: false, solo: false, type: 'bass' }
        ];

        // Patterns
        const patterns = {
            'Main Loop': createEmptyPattern(),
            'Intro': createEmptyPattern(),
            'Breakdown': createEmptyPattern(),
            'Outro': createEmptyPattern()
        };

        let currentPattern = 'Main Loop';

        // Song arrangement
        let songArrangement = ['Intro', 'Main Loop', 'Main Loop', 'Outro'];

        function createEmptyPattern() {
            return sounds.map(() => new Array(16).fill(false));
        }

        // Initialize default pattern
        function initDefaultPattern() {
            const mainLoop = patterns['Main Loop'];
            // Kick on 1, 5, 9, 13
            mainLoop[0][0] = true;
            mainLoop[0][8] = true;
            // Hat Open pattern
            mainLoop[3][0] = true;
            mainLoop[3][4] = true;
            mainLoop[3][6] = true;
            mainLoop[3][8] = true;
            mainLoop[3][10] = true;
            mainLoop[3][12] = true;
            mainLoop[3][14] = true;
            mainLoop[3][15] = true;
        }

        // Initialize UI
        function initUI() {
            initDefaultPattern();
            renderSoundRows();
            renderStepGrid();
            renderPatternBank();
            renderTimeline();
            renderModalPatterns();
        }

        function renderSoundRows() {
            const container = document.getElementById('soundRows');
            container.innerHTML = sounds.map((sound, i) => `
                <div class="sound-row">
                    <div class="sound-controls">
                        <button class="mini-btn ${sound.mute ? 'active' : ''}" onclick="toggleMute(${i})">M</button>
                        <button class="mini-btn solo ${sound.solo ? 'active' : ''}" onclick="toggleSolo(${i})">S</button>
                    </div>
                    <div class="sound-name">${sound.name}</div>
                    <div class="knob-group">
                        <div class="knob-container">
                            <div class="knob-label">DB</div>
                            <input type="number" class="knob-input" value="${sound.db}" min="-20" max="6" onchange="updateDB(${i}, this.value)">
                        </div>
                        <div class="knob-container">
                            <div class="knob-label">PAN</div>
                            <input type="number" class="knob-input" value="${sound.pan}" min="-1" max="1" step="0.1" onchange="updatePan(${i}, this.value)">
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function renderStepGrid() {
            const container = document.getElementById('stepGrid');
            const pattern = patterns[currentPattern];
            
            container.innerHTML = sounds.map((sound, soundIndex) => `
                <div class="step-row">
                    ${pattern[soundIndex].map((active, stepIndex) => `
                        <div class="step ${active ? 'active' : ''} ${stepIndex % 4 === 0 && stepIndex > 0 ? 'beat-start' : ''}" 
                             data-sound="${soundIndex}" 
                             data-step="${stepIndex}"
                             onclick="toggleStep(${soundIndex}, ${stepIndex})">
                        </div>
                    `).join('')}
                </div>
            `).join('');
        }

        function renderPatternBank() {
            const container = document.getElementById('patternGrid');
            container.innerHTML = Object.keys(patterns).map(name => `
                <button class="pattern-btn ${name === currentPattern ? 'selected' : ''}" 
                        onclick="selectPattern('${name}')">${name}</button>
            `).join('');
        }

        function renderTimeline() {
            const container = document.getElementById('timeline');
            let html = '';
            
            songArrangement.forEach((pattern, index) => {
                if (index > 0) {
                    html += '<div class="timeline-connector"></div>';
                }
                html += `
                    <div class="timeline-slot ${playMode === 'song' && isPlaying && currentSongIndex === index ? 'playing' : ''}" onclick="editSlot(${index})">
                        <span class="slot-number">${index + 1}</span>
                        ${pattern}
                        <button class="remove-btn" onclick="event.stopPropagation(); removeSlot(${index})">×</button>
                    </div>
                `;
            });
            
            html += '<div class="timeline-connector"></div>';
            html += '<button class="add-slot" onclick="addSlot()">+</button>';
            
            container.innerHTML = html;
        }

        function renderModalPatterns() {
            const container = document.getElementById('modalPatterns');
            container.innerHTML = Object.keys(patterns).map(name => `
                <button class="modal-pattern-btn" onclick="selectModalPattern('${name}')">${name}</button>
            `).join('');
        }

        // Sound functions
        function toggleMute(index) {
            sounds[index].mute = !sounds[index].mute;
            renderSoundRows();
        }

        function toggleSolo(index) {
            sounds[index].solo = !sounds[index].solo;
            renderSoundRows();
        }

        function updateDB(index, value) {
            sounds[index].db = parseFloat(value);
        }

        function updatePan(index, value) {
            sounds[index].pan = parseFloat(value);
        }

        // Step functions
        function toggleStep(soundIndex, stepIndex) {
            patterns[currentPattern][soundIndex][stepIndex] = !patterns[currentPattern][soundIndex][stepIndex];
            renderStepGrid();
        }

        // Pattern functions
        function selectPattern(name) {
            currentPattern = name;
            renderPatternBank();
            renderStepGrid();
        }

        // Timeline functions
        let editingSlotIndex = -1;

        function addSlot() {
            editingSlotIndex = songArrangement.length;
            document.getElementById('patternModal').classList.add('show');
        }

        function editSlot(index) {
            editingSlotIndex = index;
            document.getElementById('patternModal').classList.add('show');
        }

        function removeSlot(index) {
            if (songArrangement.length > 1) {
                songArrangement.splice(index, 1);
                renderTimeline();
            }
        }

        function selectModalPattern(name) {
            if (editingSlotIndex >= songArrangement.length) {
                songArrangement.push(name);
            } else {
                songArrangement[editingSlotIndex] = name;
            }
            document.getElementById('patternModal').classList.remove('show');
            renderTimeline();
        }

        function clearSong() {
            songArrangement = [];
            renderTimeline();
        }

        // Close modal on outside click
        document.getElementById('patternModal').addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                e.target.classList.remove('show');
            }
        });

        // Play mode
        function togglePlayMode() {
            playMode = playMode === 'pattern' ? 'song' : 'pattern';
            const btn = document.getElementById('playModeBtn');
            btn.textContent = playMode.toUpperCase();
            btn.classList.toggle('song-mode', playMode === 'song');
        }

        // Audio synthesis
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function playSound(soundIndex) {
            const sound = sounds[soundIndex];
            
            // Check mute/solo
            const anySolo = sounds.some(s => s.solo);
            if (sound.mute || (anySolo && !sound.solo)) return;

            const volume = Math.pow(10, sound.db / 20);
            
            const gainNode = audioContext.createGain();
            gainNode.gain.value = volume;
            
            const panNode = audioContext.createStereoPanner();
            panNode.pan.value = sound.pan;
            
            gainNode.connect(panNode);
            panNode.connect(audioContext.destination);

            switch (sound.type) {
                case 'kick':
                    playKick(gainNode);
                    break;
                case 'snare':
                    playSnare(gainNode);
                    break;
                case 'hihat':
                    playHiHat(gainNode, 0.05);
                    break;
                case 'openhat':
                    playHiHat(gainNode, 0.2);
                    break;
                case 'clap':
                    playClap(gainNode);
                    break;
                case 'perc':
                    playPerc(gainNode);
                    break;
                case 'bass':
                    playBass(gainNode);
                    break;
            }
        }

        function playKick(destination) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(destination);
            
            osc.frequency.setValueAtTime(150, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + 0.1);
            
            gain.gain.setValueAtTime(1, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.3);
        }

        function playSnare(destination) {
            // Noise
            const bufferSize = audioContext.sampleRate * 0.1;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = 1000;
            
            const noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(0.8, audioContext.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(destination);
            
            // Body
            const osc = audioContext.createOscillator();
            const oscGain = audioContext.createGain();
            osc.frequency.value = 180;
            oscGain.gain.setValueAtTime(0.5, audioContext.currentTime);
            oscGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            osc.connect(oscGain);
            oscGain.connect(destination);
            
            noise.start(audioContext.currentTime);
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.1);
        }

        function playHiHat(destination, decay) {
            const bufferSize = audioContext.sampleRate * decay;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 7000;
            
            const gain = audioContext.createGain();
            gain.gain.setValueAtTime(0.4, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + decay);
            
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(destination);
            
            noise.start(audioContext.currentTime);
        }

        function playClap(destination) {
            const bufferSize = audioContext.sampleRate * 0.15;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 1200;
            filter.Q.value = 0.5;
            
            const gain = audioContext.createGain();
            gain.gain.setValueAtTime(0.7, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(destination);
            
            noise.start(audioContext.currentTime);
        }

        function playPerc(destination) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(800, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.05);
            
            gain.gain.setValueAtTime(0.5, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
            
            osc.connect(gain);
            gain.connect(destination);
            
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.05);
        }

        function playBass(destination) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(55, audioContext.currentTime);
            
            gain.gain.setValueAtTime(0.8, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
            
            osc.connect(gain);
            gain.connect(destination);
            
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.4);
        }

        // Playback
        function updateBPM() {
            if (isPlaying) {
                stopPlayback();
                startPlayback();
            }
        }

        function togglePlayback() {
            if (isPlaying) {
                stopPlayback();
            } else {
                startPlayback();
            }
        }

        function startPlayback() {
            initAudio();
            isPlaying = true;
            currentStep = 0;
            currentSongIndex = 0;
            
            document.querySelector('.play-btn').classList.add('active');
            
            const bpm = parseInt(document.getElementById('bpm').value);
            const swing = parseInt(document.getElementById('swing').value) / 100;
            const stepDuration = (60 / bpm / 4) * 1000; // 16th notes
            
            let lastTime = performance.now();
            let accumulator = 0;
            let isSwingStep = false;
            
            function tick() {
                if (!isPlaying) return;
                
                const now = performance.now();
                const delta = now - lastTime;
                lastTime = now;
                accumulator += delta;
                
                const swingOffset = isSwingStep ? stepDuration * swing * 0.5 : 0;
                const targetDuration = stepDuration + swingOffset;
                
                if (accumulator >= targetDuration) {
                    accumulator -= targetDuration;
                    
                    // Get current pattern
                    let patternName;
                    if (playMode === 'song' && songArrangement.length > 0) {
                        patternName = songArrangement[currentSongIndex];
                    } else {
                        patternName = currentPattern;
                    }
                    
                    const pattern = patterns[patternName];
                    
                    // Play sounds
                    pattern.forEach((row, soundIndex) => {
                        if (row[currentStep]) {
                            playSound(soundIndex);
                        }
                    });
                    
                    // Update UI
                    updatePlayhead();
                    
                    // Advance step
                    isSwingStep = !isSwingStep;
                    currentStep++;
                    
                    if (currentStep >= 16) {
                        currentStep = 0;
                        
                        if (playMode === 'song' && songArrangement.length > 0) {
                            currentSongIndex++;
                            if (currentSongIndex >= songArrangement.length) {
                                currentSongIndex = 0;
                            }
                            renderTimeline();
                        }
                    }
                }
                
                requestAnimationFrame(tick);
            }
            
            requestAnimationFrame(tick);
        }

        function stopPlayback() {
            isPlaying = false;
            currentStep = 0;
            currentSongIndex = 0;
            
            document.querySelector('.play-btn').classList.remove('active');
            
            // Clear playhead indicators
            document.querySelectorAll('.step.playing').forEach(el => el.classList.remove('playing'));
            document.querySelectorAll('.timeline-slot.playing').forEach(el => el.classList.remove('playing'));
        }

        function updatePlayhead() {
            // Update step grid
            document.querySelectorAll('.step.playing').forEach(el => el.classList.remove('playing'));
            document.querySelectorAll(`.step[data-step="${currentStep}"]`).forEach(el => el.classList.add('playing'));
        }

        // WAV Export
        async function exportWAV() {
            const btn = document.getElementById('exportBtn');
            btn.disabled = true;
            btn.textContent = 'RENDERING...';

            try {
                const length = parseInt(document.getElementById('length').value);
                const bpm = parseInt(document.getElementById('bpm').value);
                const swing = parseInt(document.getElementById('swing').value) / 100;
                
                // Create offline context
                const sampleRate = 44100;
                const totalSamples = length * sampleRate;
                const offlineContext = new OfflineAudioContext(2, totalSamples, sampleRate);
                
                const stepDuration = 60 / bpm / 4; // seconds per 16th note
                
                // Calculate all events
                if (playMode === 'song' && songArrangement.length > 0) {
                    let time = 0;
                    let songIdx = 0;
                    
                    while (time < length) {
                        const patternName = songArrangement[songIdx % songArrangement.length];
                        const pattern = patterns[patternName];
                        
                        for (let step = 0; step < 16; step++) {
                            const swingOffset = step % 2 === 1 ? stepDuration * swing * 0.5 : 0;
                            const stepTime = time + swingOffset;
                            
                            if (stepTime >= length) break;
                            
                            pattern.forEach((row, soundIndex) => {
                                if (row[step]) {
                                    scheduleSoundOffline(offlineContext, soundIndex, stepTime);
                                }
                            });
                            
                            time += stepDuration;
                        }
                        
                        songIdx++;
                    }
                } else {
                    let time = 0;
                    const pattern = patterns[currentPattern];
                    let step = 0;
                    
                    while (time < length) {
                        const swingOffset = step % 2 === 1 ? stepDuration * swing * 0.5 : 0;
                        const stepTime = time + swingOffset;
                        
                        if (stepTime >= length) break;
                        
                        pattern.forEach((row, soundIndex) => {
                            if (row[step]) {
                                scheduleSoundOffline(offlineContext, soundIndex, stepTime);
                            }
                        });
                        
                        time += stepDuration;
                        step = (step + 1) % 16;
                    }
                }

                // Render
                const renderedBuffer = await offlineContext.startRendering();
                
                // Convert to WAV
                const wavBlob = bufferToWave(renderedBuffer);
                
                // Download
                const url = URL.createObjectURL(wavBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'beatsmith_export.wav';
                a.click();
                URL.revokeObjectURL(url);

            } catch (error) {
                console.error('Export failed:', error);
                alert('Export failed: ' + error.message);
            }

            btn.disabled = false;
            btn.textContent = 'EXPORT .WAV';
        }

        function scheduleSoundOffline(ctx, soundIndex, time) {
            const sound = sounds[soundIndex];
            
            const anySolo = sounds.some(s => s.solo);
            if (sound.mute || (anySolo && !sound.solo)) return;

            const volume = Math.pow(10, sound.db / 20);
            
            const gainNode = ctx.createGain();
            gainNode.gain.value = volume;
            
            const panNode = ctx.createStereoPanner();
            panNode.pan.value = sound.pan;
            
            gainNode.connect(panNode);
            panNode.connect(ctx.destination);

            switch (sound.type) {
                case 'kick':
                    scheduleKick(ctx, gainNode, time);
                    break;
                case 'snare':
                    scheduleSnare(ctx, gainNode, time);
                    break;
                case 'hihat':
                    scheduleHiHat(ctx, gainNode, time, 0.05);
                    break;
                case 'openhat':
                    scheduleHiHat(ctx, gainNode, time, 0.2);
                    break;
                case 'clap':
                    scheduleClap(ctx, gainNode, time);
                    break;
                case 'perc':
                    schedulePerc(ctx, gainNode, time);
                    break;
                case 'bass':
                    scheduleBass(ctx, gainNode, time);
                    break;
            }
        }

        function scheduleKick(ctx, destination, time) {
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.connect(gain);
            gain.connect(destination);
            
            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(40, time + 0.1);
            
            gain.gain.setValueAtTime(1, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
            
            osc.start(time);
            osc.stop(time + 0.3);
        }

        function scheduleSnare(ctx, destination, time) {
            const bufferSize = ctx.sampleRate * 0.15;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            
            const noise = ctx.createBufferSource();
            noise.buffer = buffer;
            
            const noiseFilter = ctx.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = 1000;
            
            const noiseGain = ctx.createGain();
            noiseGain.gain.setValueAtTime(0.8, time);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
            
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(destination);
            
            const osc = ctx.createOscillator();
            const oscGain = ctx.createGain();
            osc.frequency.value = 180;
            oscGain.gain.setValueAtTime(0.5, time);
            oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
            
            osc.connect(oscGain);
            oscGain.connect(destination);
            
            noise.start(time);
            osc.start(time);
            osc.stop(time + 0.15);
        }

        function scheduleHiHat(ctx, destination, time, decay) {
            const bufferSize = ctx.sampleRate * decay;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            
            const noise = ctx.createBufferSource();
            noise.buffer = buffer;
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 7000;
            
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.4, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + decay);
            
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(destination);
            
            noise.start(time);
        }

        function scheduleClap(ctx, destination, time) {
            const bufferSize = ctx.sampleRate * 0.15;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            
            const noise = ctx.createBufferSource();
            noise.buffer = buffer;
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 1200;
            filter.Q.value = 0.5;
            
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.7, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
            
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(destination);
            
            noise.start(time);
        }

        function schedulePerc(ctx, destination, time) {
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(800, time);
            osc.frequency.exponentialRampToValueAtTime(400, time + 0.05);
            
            gain.gain.setValueAtTime(0.5, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
            
            osc.connect(gain);
            gain.connect(destination);
            
            osc.start(time);
            osc.stop(time + 0.05);
        }

        function scheduleBass(ctx, destination, time) {
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(55, time);
            
            gain.gain.setValueAtTime(0.8, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
            
            osc.connect(gain);
            gain.connect(destination);
            
            osc.start(time);
            osc.stop(time + 0.4);
        }

        function bufferToWave(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;
            
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            
            const dataLength = buffer.length * blockAlign;
            const bufferLength = 44 + dataLength;
            
            const arrayBuffer = new ArrayBuffer(bufferLength);
            const view = new DataView(arrayBuffer);
            
            // WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, bufferLength - 8, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);
            
            // Interleave channels
            const channels = [];
            for (let i = 0; i < numChannels; i++) {
                channels.push(buffer.getChannelData(i));
            }
            
            let offset = 44;
            for (let i = 0; i < buffer.length; i++) {
                for (let ch = 0; ch < numChannels; ch++) {
                    let sample = channels[ch][i];
                    sample = Math.max(-1, Math.min(1, sample));
                    sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    view.setInt16(offset, sample, true);
                    offset += 2;
                }
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !e.target.matches('input')) {
                e.preventDefault();
                togglePlayback();
            }
        });

        // Initialize
        initUI();
    </script>
</body>
</html>
